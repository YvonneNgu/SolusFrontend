# Implementing LiveKit Token Authentication in Android (Kotlin + Jetpack)

## Overview

Based on the token server we've created and the LiveKit documentation, I'll provide a detailed guide for implementing token authentication in an Android application using Kotlin and Jetpack Compose. This guide will show you how to request tokens from your backend server and use them to connect to LiveKit rooms.

## 1. Project Setup

First, add the LiveKit Android SDK to your project by adding these dependencies in your `build.gradle` file:

```kotlin
// In your app's build.gradle
dependencies {
    // LiveKit Android SDK
    implementation("io.livekit:livekit-android:1.2.0")
    
    // For API calls to your token server
    implementation("com.squareup.retrofit2:retrofit:2.9.0")
    implementation("com.squareup.retrofit2:converter-gson:2.9.0")
    implementation("com.squareup.okhttp3:okhttp:4.11.0")
    
    // Jetpack Compose dependencies
    implementation("androidx.compose.ui:ui:1.5.0")
    implementation("androidx.compose.material3:material3:1.1.0")
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.6.1")
    // ... other dependencies
}
```

## 2. Create API Service for Token Server

Set up a Retrofit service to communicate with your token server:

```kotlin
// Models for token requests and responses
data class TokenRequest(
    val identity: String,
    val room: String,
    val name: String? = null,
    val metadata: String? = null,
    val agent_name: String? = null,
    val agent_metadata: String? = null
)

data class TokenResponse(
    val token: String
)

// Retrofit API interface
interface TokenServerApi {
    @POST("token")
    suspend fun getStandardToken(@Body request: TokenRequest): Response<TokenResponse>
    
    @POST("token/subscribe-only")
    suspend fun getSubscribeOnlyToken(@Body request: TokenRequest): Response<TokenResponse>
    
    @POST("token/camera-only")
    suspend fun getCameraOnlyToken(@Body request: TokenRequest): Response<TokenResponse>
    
    @POST("token/with-solus")
    suspend fun getSolusAgentToken(@Body request: TokenRequest): Response<TokenResponse>
    
    @POST("token/with-agent")
    suspend fun getCustomAgentToken(@Body request: TokenRequest): Response<TokenResponse>
    
    @POST("token/custom")
    suspend fun getCustomToken(@Body request: TokenRequest): Response<TokenResponse>
}

// Create Retrofit client
object RetrofitClient {
    private const val BASE_URL = "http://your-token-server-url:5000/"
    
    private val client = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .build()
    
    private val retrofit = Retrofit.Builder()
        .baseUrl(BASE_URL)
        .client(client)
        .addConverterFactory(GsonConverterFactory.create())
        .build()
    
    val tokenApi: TokenServerApi = retrofit.create(TokenServerApi::class.java)
}
```

## 3. Create a Repository for Token Operations

```kotlin
class TokenRepository {
    private val tokenApi = RetrofitClient.tokenApi
    
    suspend fun getStandardToken(
        identity: String,
        roomName: String,
        displayName: String? = null
    ): Result<String> {
        return try {
            val request = TokenRequest(
                identity = identity,
                room = roomName,
                name = displayName
            )
            
            val response = tokenApi.getStandardToken(request)
            if (response.isSuccessful) {
                response.body()?.token?.let {
                    Result.success(it)
                } ?: Result.failure(Exception("Empty token response"))
            } else {
                Result.failure(Exception("Failed to get token: ${response.code()} ${response.message()}"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun getSolusAgentToken(
        identity: String,
        roomName: String,
        displayName: String? = null
    ): Result<String> {
        return try {
            val request = TokenRequest(
                identity = identity,
                room = roomName,
                name = displayName
            )
            
            val response = tokenApi.getSolusAgentToken(request)
            if (response.isSuccessful) {
                response.body()?.token?.let {
                    Result.success(it)
                } ?: Result.failure(Exception("Empty token response"))
            } else {
                Result.failure(Exception("Failed to get token: ${response.code()} ${response.message()}"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun getCustomAgentToken(
        identity: String,
        roomName: String,
        agentName: String,
        agentMetadata: String? = null,
        displayName: String? = null
    ): Result<String> {
        return try {
            val request = TokenRequest(
                identity = identity,
                room = roomName,
                name = displayName,
                agent_name = agentName,
                agent_metadata = agentMetadata
            )
            
            val response = tokenApi.getCustomAgentToken(request)
            if (response.isSuccessful) {
                response.body()?.token?.let {
                    Result.success(it)
                } ?: Result.failure(Exception("Empty token response"))
            } else {
                Result.failure(Exception("Failed to get token: ${response.code()} ${response.message()}"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    // Implement other token request methods as needed...
}
```

## 4. Create a LiveKit Connection Manager

This class will handle connecting to LiveKit rooms and manage the room lifecycle:

```kotlin
class LiveKitManager(private val context: Context) {
    private lateinit var room: Room
    private val tokenRepository = TokenRepository()
    
    // LiveKit server URL - set this to your LiveKit server address
    private val liveKitUrl = "wss://your-livekit-server-url"
    
    init {
        // Initialize room with context
        room = Room(context)
        
        // Set up room event listeners
        setupRoomListeners()
    }
    
    private fun setupRoomListeners() {
        room.setListener(object : RoomListener {
            override fun onConnected(params: RoomOptions?) {
                Log.d("LiveKitManager", "Room connected")
            }
            
            override fun onDisconnected(error: Exception?) {
                Log.d("LiveKitManager", "Room disconnected: ${error?.message}")
            }
            
            override fun onParticipantConnected(participant: RemoteParticipant) {
                Log.d("LiveKitManager", "Participant connected: ${participant.identity}")
            }
            
            override fun onParticipantDisconnected(participant: RemoteParticipant) {
                Log.d("LiveKitManager", "Participant disconnected: ${participant.identity}")
            }
            
            // Implement other room listeners as needed
        })
    }
    
    suspend fun connectWithSolusAgent(
        identity: String,
        roomName: String,
        displayName: String? = null
    ): Result<Room> {
        return try {
            // Get token for room with Solus agent
            val tokenResult = tokenRepository.getSolusAgentToken(identity, roomName, displayName)
            
            if (tokenResult.isSuccess) {
                val token = tokenResult.getOrThrow()
                
                // Connect to the room with the token
                val roomOptions = RoomOptions(
                    adaptiveStream = true,
                    dynacast = true
                )
                
                try {
                    room.connect(liveKitUrl, token, roomOptions)
                    Result.success(room)
                } catch (e: Exception) {
                    Result.failure(Exception("Failed to connect to room: ${e.message}"))
                }
            } else {
                Result.failure(tokenResult.exceptionOrNull() ?: Exception("Unknown token error"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun connectWithCustomAgent(
        identity: String,
        roomName: String,
        agentName: String,
        agentMetadata: String? = null,
        displayName: String? = null
    ): Result<Room> {
        return try {
            // Get token for room with custom agent
            val tokenResult = tokenRepository.getCustomAgentToken(
                identity, roomName, agentName, agentMetadata, displayName
            )
            
            if (tokenResult.isSuccess) {
                val token = tokenResult.getOrThrow()
                
                // Connect to the room with the token
                val roomOptions = RoomOptions(
                    adaptiveStream = true,
                    dynacast = true
                )
                
                try {
                    room.connect(liveKitUrl, token, roomOptions)
                    Result.success(room)
                } catch (e: Exception) {
                    Result.failure(Exception("Failed to connect to room: ${e.message}"))
                }
            } else {
                Result.failure(tokenResult.exceptionOrNull() ?: Exception("Unknown token error"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    fun disconnect() {
        try {
            room.disconnect()
            Log.d("LiveKitManager", "Disconnected from room")
        } catch (e: Exception) {
            Log.e("LiveKitManager", "Error disconnecting from room: ${e.message}")
        }
    }
    
    fun getRoom(): Room {
        return room
    }
}
```

## 5. Create a ViewModel

Set up a ViewModel to manage the LiveKit connection lifecycle and expose state to the UI:

```kotlin
class LiveKitViewModel(application: Application) : AndroidViewModel(application) {
    private val liveKitManager = LiveKitManager(application)
    
    private val _connectionState = MutableStateFlow<ConnectionState>(ConnectionState.Disconnected)
    val connectionState: StateFlow<ConnectionState> = _connectionState
    
    private val _roomState = MutableStateFlow<RoomState>(RoomState.Empty)
    val roomState: StateFlow<RoomState> = _roomState
    
    fun connectToRoomWithSolusAgent(
        identity: String,
        roomName: String,
        displayName: String? = null
    ) {
        _connectionState.value = ConnectionState.Connecting
        
        viewModelScope.launch {
            val result = liveKitManager.connectWithSolusAgent(identity, roomName, displayName)
            
            if (result.isSuccess) {
                _connectionState.value = ConnectionState.Connected
                trackRoomState(liveKitManager.getRoom())
            } else {
                _connectionState.value = ConnectionState.Error(
                    result.exceptionOrNull()?.message ?: "Unknown connection error"
                )
            }
        }
    }
    
    fun connectToRoomWithCustomAgent(
        identity: String,
        roomName: String,
        agentName: String,
        agentMetadata: String? = null,
        displayName: String? = null
    ) {
        _connectionState.value = ConnectionState.Connecting
        
        viewModelScope.launch {
            val result = liveKitManager.connectWithCustomAgent(
                identity, roomName, agentName, agentMetadata, displayName
            )
            
            if (result.isSuccess) {
                _connectionState.value = ConnectionState.Connected
                trackRoomState(liveKitManager.getRoom())
            } else {
                _connectionState.value = ConnectionState.Error(
                    result.exceptionOrNull()?.message ?: "Unknown connection error"
                )
            }
        }
    }
    
    private fun trackRoomState(room: Room) {
        viewModelScope.launch {
            // This is a simplistic approach - in a real app you'd want to use LiveKit's events
            while (_connectionState.value is ConnectionState.Connected) {
                _roomState.value = RoomState(
                    participants = room.remoteParticipants.map { it.identity },
                    isConnected = room.state == Room.State.CONNECTED
                )
                delay(1000) // Update state every second
            }
        }
    }
    
    fun disconnect() {
        liveKitManager.disconnect()
        _connectionState.value = ConnectionState.Disconnected
        _roomState.value = RoomState.Empty
    }
    
    override fun onCleared() {
        super.onCleared()
        liveKitManager.disconnect()
    }
    
    // State classes
    sealed class ConnectionState {
        object Disconnected : ConnectionState()
        object Connecting : ConnectionState()
        object Connected : ConnectionState()
        data class Error(val message: String) : ConnectionState()
    }
    
    data class RoomState(
        val participants: List<String> = emptyList(),
        val isConnected: Boolean = false
    ) {
        companion object {
            val Empty = RoomState()
        }
    }
}
```

## 6. Create a Composable UI

Here's a simple Jetpack Compose UI that allows the user to connect to a room with an agent:

```kotlin
@Composable
fun VoiceAssistantScreen(
    viewModel: LiveKitViewModel = viewModel()
) {
    val connectionState by viewModel.connectionState.collectAsState()
    val roomState by viewModel.roomState.collectAsState()
    
    var identity by remember { mutableStateOf("") }
    var roomName by remember { mutableStateOf("") }
    var displayName by remember { mutableStateOf("") }
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            text = "Solus Voice Assistant",
            style = MaterialTheme.typography.headlineMedium,
            modifier = Modifier.padding(bottom = 24.dp)
        )
        
        OutlinedTextField(
            value = identity,
            onValueChange = { identity = it },
            label = { Text("User Identity") },
            modifier = Modifier.fillMaxWidth()
        )
        
        Spacer(modifier = Modifier.height(8.dp))
        
        OutlinedTextField(
            value = roomName,
            onValueChange = { roomName = it },
            label = { Text("Room Name") },
            modifier = Modifier.fillMaxWidth()
        )
        
        Spacer(modifier = Modifier.height(8.dp))
        
        OutlinedTextField(
            value = displayName,
            onValueChange = { displayName = it },
            label = { Text("Display Name (Optional)") },
            modifier = Modifier.fillMaxWidth()
        )
        
        Spacer(modifier = Modifier.height(24.dp))
        
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            Button(
                onClick = {
                    viewModel.connectToRoomWithSolusAgent(
                        identity = identity,
                        roomName = roomName,
                        displayName = displayName.takeIf { it.isNotEmpty() }
                    )
                },
                enabled = identity.isNotEmpty() && roomName.isNotEmpty() &&
                         connectionState !is LiveKitViewModel.ConnectionState.Connecting
            ) {
                Text("Connect with Solus")
            }
            
            Button(
                onClick = {
                    viewModel.disconnect()
                },
                enabled = connectionState is LiveKitViewModel.ConnectionState.Connected
            ) {
                Text("Disconnect")
            }
        }
        
        Spacer(modifier = Modifier.height(24.dp))
        
        when (connectionState) {
            is LiveKitViewModel.ConnectionState.Disconnected -> {
                Text("Disconnected", color = Color.Gray)
            }
            is LiveKitViewModel.ConnectionState.Connecting -> {
                CircularProgressIndicator()
                Text("Connecting...", color = Color.Blue)
            }
            is LiveKitViewModel.ConnectionState.Connected -> {
                Text("Connected!", color = Color.Green)
                
                Spacer(modifier = Modifier.height(16.dp))
                
                Text("Participants in room:")
                roomState.participants.forEach { participant ->
                    Text("â€¢ $participant")
                }
            }
            is LiveKitViewModel.ConnectionState.Error -> {
                val error = (connectionState as LiveKitViewModel.ConnectionState.Error).message
                Text("Error: $error", color = Color.Red)
            }
        }
    }
}
```

## 7. Set up Permissions

Add the necessary permissions to your AndroidManifest.xml:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.voiceassistant">
    
    <!-- Internet permission -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    
    <!-- For voice interaction -->
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    
    <!-- For video -->
    <uses-permission android:name="android.permission.CAMERA" />
    
    <!-- For screenshots (if needed) -->
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    
    <!-- ... rest of your manifest -->
</manifest>
```

## 8. Request Runtime Permissions

Add permission handling in your main activity:

```kotlin
class MainActivity : ComponentActivity() {
    private val requiredPermissions = arrayOf(
        Manifest.permission.RECORD_AUDIO,
        Manifest.permission.CAMERA
    )
    
    private val permissionLauncher = registerForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { permissionsMap ->
        val allGranted = permissionsMap.entries.all { it.value }
        if (allGranted) {
            // Permissions granted, proceed
        } else {
            // Show dialog explaining why permissions are needed
            showPermissionRationaleDialog()
        }
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Check and request permissions
        requestPermissionsIfNeeded()
        
        setContent {
            YourAppTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    val viewModel: LiveKitViewModel = viewModel()
                    VoiceAssistantScreen(viewModel)
                }
            }
        }
    }
    
    private fun requestPermissionsIfNeeded() {
        val permissionsToRequest = requiredPermissions.filter {
            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED
        }.toTypedArray()
        
        if (permissionsToRequest.isNotEmpty()) {
            permissionLauncher.launch(permissionsToRequest)
        }
    }
    
    private fun showPermissionRationaleDialog() {
        AlertDialog.Builder(this)
            .setTitle("Permissions Required")
            .setMessage("Voice and camera permissions are needed for the voice assistant to function correctly.")
            .setPositiveButton("Grant") { _, _ -> requestPermissionsIfNeeded() }
            .setNegativeButton("Cancel", null)
            .show()
    }
}
```

## 9. Implementation for AI Voice Agent Scenario

For a voice assistant, you'll primarily focus on audio tracks. According to the LiveKit documentation, a typical AI voice agent scenario involves:

- End-user publishing their microphone track and subscribing to the agent's audio output
- AI agent subscribing to the user's audio and publishing synthesized speech

Here's an example of how to set up audio tracks:

```kotlin
// In your LiveKitManager or a separate audio manager class

fun enableUserMicrophone(room: Room): AudioTrack? {
    return try {
        // Get microphone track options
        val options = AudioCaptureOptions(
            echoCancellation = true,
            noiseSuppression = true,
            autoGainControl = true
        )
        
        // Create local audio track
        val audioTrack = LocalAudioTrack.createTrack(context, options)
        
        // Publish to room
        room.localParticipant.publishAudioTrack(audioTrack)
        
        Log.d("LiveKitManager", "Published microphone track")
        audioTrack
    } catch (e: Exception) {
        Log.e("LiveKitManager", "Failed to publish microphone: ${e.message}")
        null
    }
}

fun subscribeToAgentAudio(room: Room, participant: RemoteParticipant) {
    // Set up listener for agent audio tracks
    participant.setListener(object : ParticipantListener {
        override fun onTrackSubscribed(
            track: Track,
            publication: RemoteTrackPublication,
            participant: RemoteParticipant
        ) {
            if (track is AudioTrack) {
                Log.d("LiveKitManager", "Subscribed to agent audio track")
                // Handle the agent's audio track (e.g., route to speakers)
                track.play() // This will play the audio through the device speakers
            }
        }
        
        // Implement other participant listener methods
    })
}
```

## 10. Handling Byte Streams for Screenshots

If you need to send screenshots to the Solus agent, use the byte stream functionality:

```kotlin
suspend fun sendScreenshot(room: Room, bitmap: Bitmap) {
    try {
        // Convert bitmap to bytes
        val baos = ByteArrayOutputStream()
        bitmap.compress(Bitmap.CompressFormat.PNG, 100, baos)
        val imageBytes = baos.toByteArray()
        
        // Create byte stream writer
        val writer = room.createByteStreamWriter("screenshot")
        
        // Write image bytes
        writer.write(imageBytes)
        
        // Close stream
        writer.close()
        
        Log.d("LiveKitManager", "Screenshot sent (${imageBytes.size} bytes)")
    } catch (e: Exception) {
        Log.e("LiveKitManager", "Failed to send screenshot: ${e.message}")
    }
}

// Function to capture screenshot from an Android view
fun captureScreenshot(view: View): Bitmap {
    view.isDrawingCacheEnabled = true
    val bitmap = Bitmap.createBitmap(view.drawingCache)
    view.isDrawingCacheEnabled = false
    return bitmap
}
```

## Complete Example Flow

Here's a typical flow for using the Solus Voice Assistant:

1. User launches the app and enters their identity and room name
2. App requests a token with Solus agent from your token server
3. App connects to LiveKit room using the token
4. App publishes the user's microphone audio track
5. App subscribes to the Solus agent's audio track
6. User can speak and hear the agent's responses
7. Every time user stop speaking, automatically send screenshot of current screen for visual context

### Best Practices

1. **Token Security**: Never store the LiveKit API key and secret on the client. Always request tokens from your backend server.

2. **Error Handling**: Implement comprehensive error handling for network issues, permission denials, and LiveKit connection problems.

3. **Connection State**: Provide clear feedback to users about connection status and any issues.

4. **Lifecycle Management**: Properly handle application lifecycle events to disconnect and clean up resources when the app goes to the background.

5. **Permissions**: Request permissions at the appropriate time and provide clear rationale to users.

6. **Background Audio**: If your app needs to maintain audio connections in the background, implement the necessary services and lifecycle handling.

This guide provides a solid foundation for implementing LiveKit token authentication and real-time audio communication in your Android app.